URL: https://github.com/trmarvin/DI-Bootcamp/blob/main/Week01/Day5/DailyChallenge/01_05_DC.py
suggestions for improvement:
- In Challenge 1, the code could include more robust error handling for non-string inputs.  Currently, it will throw an error if the user enters anything other than a string.
- In Challenge 2, the price cleaning using `replace()` is effective but might be made more robust with regular expressions for handling a wider range of price formats (e.g., prices with multiple commas or different currency symbols).
- For better readability in Challenge 2, consider extracting the price cleaning logic into a separate function to improve maintainability and reusability.
Brief justification:
- correctness: Both challenges are correctly implemented. Challenge 1 accurately creates a dictionary mapping characters to their indices as specified, handling both single and multiple occurrences. Challenge 2 correctly processes the input data, cleans the price strings, compares prices with the wallet amount, and returns the sorted list of affordable items or "Nothing" as expected.  The code directly addresses all the requirements outlined in the Chapter Content/Questions section.
- readability: The code is generally well-structured and easy to follow.  Variable names are descriptive. The use of `enumerate()` in Challenge 1 enhances readability.  Minor improvements in error handling and function decomposition would enhance readability further.
- performance: The performance is acceptable for small inputs.  However, for very large input strings or item dictionaries, the linear time complexity of the loops might become noticeable. More efficient algorithms (like using a hashmap for character lookups in Challenge 1) could be implemented for better performance with large datasets. The current price cleaning in Challenge 2, while functional, could be slightly optimized if the input data was extremely large.
- security: The code does not have any obvious security vulnerabilities.  It directly uses user input without attempting to execute it as code, and performs basic data type checking (implicit conversion of input into strings, but no explicit checks).  However, for production-level code, more robust input validation would be essential to prevent unexpected behavior from malicious or improperly formatted input.

